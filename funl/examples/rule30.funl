version("a-5")

-- Constants
SIZE = int(20)
MIDDLE = int(div(SIZE(), int(2)))
ITERATIONS = int(5)

-- Generates an empty array
-- IN   i     int(0)      Current iteration
-- IN   max   int         Size of the array
-- OUT        arr(bool)   The resulting empty array
gen_empty_state = (i, max) {
    eval(eq(i(), int(0)),   { res = arr(bool) })
    eval(gt(i(), int(0)),   { res = arr_push(res(), int(0)) })
    eval(lt(i(), max()),    { res = gen_empty_state(add(i(), int(1)), max()) })
    return(res())
}

-- Applies "Rule 30" rulebook to input array
-- IN   current_state   arr(bool)   Current state of the system
-- OUT                  arr(bool)   Next state of the system
gen_next_state = (current_state) {
    res = arr(bool)

    -- Iterates over the cells of the system
    iter = (i, max) {
        updated_state = bool(0) -- new state cell defaults to bool(0)

        -- Check bounds
        eval(gt(i(), int(0)), {
        eval(lt(i(), max()), {
            -- Apply all rules that may turn the cell to bool(1)
            eval(and(
                    eq(current_state(add(i(), int(1))),    bool(1)),
                    eq(current_state(i()),                 bool(0)),
                    eq(current_state(sub(i(), int(1))),    bool(0))), {
                updated_state = bool(1)
            })

            eval(and(
                    eq(current_state(add(i(), int(1))),    bool(0)),
                    eq(current_state(i()),                 bool(1)),
                    eq(current_state(sub(i(), int(1))),    bool(0))), {
                updated_state = bool(1)
            })

            eval(and(
                    eq(current_state(add(i(), int(1))),    bool(0)),
                    eq(current_state(i()),                 bool(0)),
                    eq(current_state(sub(i(), int(1))),    bool(1))), {
                updated_state = bool(1)
            })

            eval(and(
                    eq(current_state(add(i(), int(1))),    bool(1)),
                    eq(current_state(i()),                 bool(1)),
                    eq(current_state(sub(i(), int(1))),    bool(0))), {
                updated_state = bool(1)
            })
        })})

        -- Append updated cell and repeat process
        res = arr_push(res(), updated_state())
        eval(lt(i(), max()), {
            res = iter(add(i(), int(1)), max())
        })

        return(res())
    }
    res = iter(int(0), sub(SIZE(), int(1)))

    return(res())
}

-- Simulates Rule 30 for n amount of iterations
-- https://en.wikipedia.org/wiki/Rule_30
-- IN   current_state   arr(bool)   Current state of the system
-- IN   i               int(0)      Current iteration
-- IN   n               int()       Maximum amount of iterations
rule_30 = (current_state, i, n) {
    new_state = gen_next_state(current_state())
    draw(new_state())

    eval(lt(i(), n()), {
        rule_30(new_state(), add(i(), int(1)), n())
    })
}

-- Setup the initial state
initial_state = gen_empty_state(int(0), SIZE())
initial_state = arr_set(initial_state(), MIDDLE(), int(1))

-- Draw initial state and simulate Rule 30
draw(initial_state())
rule_30(initial_state(), int(0), ITERATIONS())
